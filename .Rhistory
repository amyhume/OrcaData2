token <- '2338CA1AE27CE6932A075CF7B7931827'
devtools::install_github("amyhume/OrcaData")
library(OrcaData)
dq <- get_orca_data(token, form="data_quality_visit_1")
View(dq)
dq <- get_orca_data(token, form="data_quality_visit_1", form_complete = F)
get_orca_data2 <- function(token = token, form = form, raw_v_label = 'raw', form_complete = T) {
if (form_complete) {
record_filter = paste("[", form, "_complete]=2", sep = "")
} else {
record_filter = ""
}
formData <- list(uri = url,
"token"=token,
content='record',
format='csv',
type='flat',
csvDelimiter='',
'fields[0]'='record_id',
'forms[0]'=form,
rawOrLabel=raw_v_label,
rawOrLabelHeaders=raw_v_label,
exportCheckboxLabel='false',
exportSurveyFields='true',
exportDataAccessGroups='false',
returnFormat='csv',
filterLogic=record_filter)
response <- httr::POST(url, body = formData, encode = "form")
df <- httr::content(response)
df[df == -888] = NA
df[df == 888] = NA
df[df == 8888] = NA
df[df == -999] = NA
df[df == 999] = NA
df[df == 9999] = NA # NOTE values can be changed, or new ones added, to account for different missing data flags
return (df)
}
dq <- get_orca_data2(token, form="data_quality_visit_1", form_complete = F)
url <- 'https://redcap.nyu.edu/api/'
dq <- get_orca_data2(token, form="data_quality_visit_1", form_complete = F)
View(dq)
test_ids <- dq$record_id
View(dq)
library(tidyverse)
test_ids <- test_ids[str_detect(test_ids, 'TEST')]
print(test_ids)
ids <- c('049', '050', '099')
dq <- dq %>%
filter(str_detect(record_id, any(ids)))
dq <- dq %>%
filter(record_id %in% ids)
View(dq)
dq <- get_orca_data2(token, form="data_quality_visit_1", form_complete = F)
dq <- dq %>%
filter(str_detect(record_id, paste(ids, collapse = '|')))
View(dq)
ah <- dq %>%
filter(record_id %in% ids)
ng <- dq %>%
filter(str_detect(record_id, "NG"))
View(ng)
View(ah)
ah <- dq %>%
filter(record_id %in% ids) %>%
filter(redcap_event_name == 'orca_visit_1_arm_1')
View(ah)
ly <- dq %>%
filter(str_detect(record_id, "LY"))
sa <- dq %>%
filter(str_detect(record_id, "SA"))
ah <- dq %>%
filter(record_id %in% ids) %>%
filter(redcap_event_name == 'orca_visit_1_arm_1') %>%
select(record_id, cecile_dq_notes, vpc_dq_score, memory_dq_score, maap_dq_score)
ng <- dq %>%
filter(str_detect(record_id, "NG")) %>%
select(record_id, cecile_dq_notes, vpc_dq_score, memory_dq_score, maap_dq_score)
ah <- dq %>%
filter(record_id %in% ids) %>%
filter(redcap_event_name == 'orca_visit_1_arm_1') %>%
select(record_id, cecile_dq_score, vpc_dq_score, memory_dq_score, maap_dq_score)
ng <- dq %>%
filter(str_detect(record_id, "NG")) %>%
select(record_id, cecile_dq_score, vpc_dq_score, memory_dq_score, maap_dq_score)
ng$record_id <- gsub("TEST_", "", ng$record_id)
ng$record_id <- gsub("_NG", "", ng$record_id)
View(ng)
ah_ng <- ah %>%
left_join(ng, by="record_id")
View(ah_ng)
library(CopeData)
token <- 'D4DF5D2839A15994FCEC02E51B81C609'
library(tidyverse)
notes_42m <- get_data(token, form = 'm_home_visit_notes')
View(notes_42m)
notes_42m <- notes_42m %>%
select(record_id, fnirs_cg_so_42m, fnirs_child_so_42m, fnirs_notes_42m)
View(notes_42m)
notes_42m <- notes_42m %>%
select(record_id, fnirs_cg_so_42m, fnirs_child_so_42m, fnirs_notes_42m) %>%
filter(fnirs_cg_so_42m == 4 | fnirs_child_so_42m == 4)
library(redcapAPI)
url <- 'https://redcap.nyu.edu/api/'
token <- '950056F36783568FBA0900EFAE8AA4A4'
library(tidyverse)
library(zipcodeR)
library(maps)
screener = get_orca_data(token, "orca_screener_survey")
library(redcapAPI)
url <- 'https://redcap.nyu.edu/api/'
#' @title Pulling ORCA Data
#' @description This function retrieves data from a REDCap project using the API.
#' @param token The API token for the project
#' @param form The name of the REDCap form to retrieve data from
#' @param raw_v_label The label for raw data fields
#' @param form_complete Indicating whether you want to return all responses or just ones marked as complete (default is all)
#' @return A data frame with the retrieved data
#' @export
get_orca_data <- function(token = token, form = form, raw_v_label = 'raw', form_complete = T) {
if (form_complete) {
record_filter = paste("[", form, "_complete]=2", sep = "")
} else {
record_filter = ""
}
formData <- list(uri = url,
"token"=token,
content='record',
format='csv',
type='flat',
csvDelimiter='',
'fields[0]'='record_id',
'forms[0]'=form,
rawOrLabel=raw_v_label,
rawOrLabelHeaders=raw_v_label,
exportCheckboxLabel='false',
exportSurveyFields='true',
exportDataAccessGroups='false',
returnFormat='csv',
filterLogic=record_filter)
response <- httr::POST(url, body = formData, encode = "form")
df <- httr::content(response)
df <- dplyr::filter(df, !stringr::str_detect(record_id, "TEST"))
return (df)
}
#' @title Pulling ORCA Field
#' @description PULLS RECORD ID AND INDIVIDUAL FIELD
#' @param token Unique REDCap token ID
#' @param field Name of the specific field to be downloaded
#' @param raw_v_label Whether raw data or labels are requested
#' @return A data frame for the completed record_ids, redcap_event_name and field
#' @export
get_orca_field <- function(token = token, field=field, raw_v_label = 'raw') {
formData <- list(uri = url,
"token"=token,
content='record',
format='csv',
type='flat',
csvDelimiter='',
'fields[0]'='record_id',
'fields[1]' = field,
rawOrLabel=raw_v_label,
rawOrLabelHeaders=raw_v_label,
exportCheckboxLabel='false',
exportSurveyFields='false',
exportDataAccessGroups='false',
returnFormat='csv')
response <- httr::POST(url, body = formData, encode = "form")
df <- httr::content(response)
df[df == -888] = NA
df[df == 888] = NA
df[df == 8888] = NA
df[df == -999] = NA
df[df == 999] = NA
df[df == 9999] = NA
df <- dplyr::select(df, record_id, redcap_event_name, field)
df <- df[!is.na(df[[field]]),]
df <- dplyr::filter(df, !stringr::str_detect(record_id, "TEST"))
return (df)
}
#' @title Replacing Multiple Values Function
#' @description ALLOWS DATA TO BE REPLACED IN A COLUMN
#' @param data The dataframe
#' @param column_name The column you wish to work on
#' @param old_values Vector of string variables you wish to replace
#' @param new_values Vector of string variables you wish to replace the old ones with
#' @return the data frame with old strings in specified column replaced with new strings
#' @export
#'
replace_multiple <- function(data, column_name, old_values, new_values) {
data[[column_name]] <- new_values[match(data[[column_name]], old_values)]
return(data)
}
#' @title Cleaning screener race responses
#' @description This function cleans race responses
#' @param data data frame to act upon
#' @return a dataframe with the race responses cleaned
#' @export
clean_race <- function(data) {
data$rec_race___1 <- gsub("1", "American Indian/Alaska Native", data$rec_race___1)
data$rec_race___2 <- gsub("1", "Asian", data$rec_race___2)
data$rec_race___3 <- gsub("1", "Black/African American/African", data$rec_race___3)
data$rec_race___4 <- gsub("1", "Hispanic/Latino", data$rec_race___4)
data$rec_race___5 <- gsub("1", "Middle Eastern/North African", data$rec_race___5)
data$rec_race___6 <- gsub("1", "Native Hawaiian", data$rec_race___6)
data$rec_race___7 <- gsub("1", "White", data$rec_race___7)
data$rec_race___8 <- gsub("1", "None fully describe", data$rec_race___8)
data$rec_race___9 <- gsub("1", "Prefer not to answer", data$rec_race___9)
data <- unite(data, "race", rec_race___1:rec_race___9)
data$race <- gsub("0", "", data$race)
data$race <- gsub("_", "", data$race)
return (data)
}
#' @title ZIP CODE AND LOCATION FUNCTION
#' @description This function pulls public US zipcode data and cleans it
#' @return a dataframe with the race responses cleaned
#' @export
zips <- function() {
zipcodeR::download_zip_data(force=T)
zip_info <- select(zipcodeR::zip_code_db, zipcode, major_city, state, timezone)
zip_info$zipcode <- as.integer(zip_info$zipcode)
zip_info <- mutate(zip_info,
final_city = ifelse(zipcode >= 10001 & zipcode <= 10282, "New York",
ifelse(zipcode >= 10301 & zipcode <= 10314, "New York",
ifelse(zipcode >= 10451 & zipcode <= 10475, "New York",
ifelse(zipcode >= 11004 & zipcode <= 11109, "New York",
ifelse(zipcode >= 11351 & zipcode <= 11697, "New York",
ifelse(zipcode >= 11201 & zipcode <= 11256, "New York", major_city)))))))
zip_info$location <- str_c(zip_info$final_city, " ", zip_info$state)
zip_info <- select(zip_info, zipcode, location, timezone)
zip_info <- data.frame(zip_info)
return(zip_info)
}
#' @title Pulling City Data
#' @description this function pulls us city population data
#' @param data data frame to act upon
#' @return a dataframe with the race responses cleaned
#' @export
city_info <- function() {
cities <- maps::us.cities
cities <- select(cities, name, pop)
cities <- rename(cities, location = name, population=pop)
cities <- data.frame(cities)
return(cities)
}
#' @title Pulling cleaned screener responses
#' @description this function pulls and cleans screener data for import to excel tracker
#' @param token Unique REDCap API token
#' @param min_date_time The minimum timestamp to pull responses after
#' @return a dataframe with the race responses cleaned
#' @export
screener = get_orca_data(token, "orca_screener_survey")
screener = select(screener, -redcap_survey_identifier, -rec_unique_record_id, -orca_screener_survey_complete)
screener = rename(screener,
screener_record_id = record_id,
timestamp = orca_screener_survey_timestamp,
language = rec_language_preference,
caregiver_firstname = rec_caregiver_name,
caregiver_lastname = rec_caregiver_name_last,
phone = rec_phone_number,
texting_okay = rec_phone_number_text,
email = rec_caregiver_email,
over_18 = rec_over_18,
zipcode = rec_address_zipcode,
race_other = rec_race_other,
child_yesno = rec_child_yesno,
child_dob = rec_child_dob,
pregnant_yesno = rec_pregnant_yesno,
due_date = rec_due_date,
twin_yesno = rec_twin,
education = rec_education_level)
screener$timestamp = strptime(screener$timestamp, format = "%Y-%m-%d %H:%M:%S")
min_date_time = strptime(min_date_time, format = "%Y-%m-%d %H:%M:%S")
screener = filter(screener, timestamp > min_date_time)
screener = clean_race(screener)
screener$zipcode <- as.integer(screener$zipcode)
zip_info <- zips()
cities <- city_info()
screener <- left_join(screener, zip_info, by="zipcode")
screener <- left_join(screener, cities, by="location")
screener <- mutate(screener,
rural = ifelse(is.na(population) & !is.na(location), "Y",
ifelse(population >= 50000, "N",
ifelse(population < 50000, "Y", "CHECK"))))
screener <- mutate(screener, non_white = ifelse(race == "White", "N", "Y"))
screener <- mutate(screener, low_ses = ifelse(education == 4, "N",
ifelse(education == 3, "N", "Y")))
screener <- mutate(screener, priority = case_when(
rural == 'N' & non_white == 'N' & low_ses == 'N' ~ 'Low Priority',
rural == 'Y' | non_white == 'Y' | low_ses == 'Y' ~ 'High Priority'
))
screener$current_age <- as.numeric(difftime(Sys.Date(), screener$child_dob, units = 'days'))
screener$child_yesno <- ifelse(is.na(screener$child_yesno), 0, screener$child_yesno)
screener$pregnant_yesno <- ifelse(is.na(screener$pregnant_yesno), 0, screener$pregnant_yesno)
for (i in 1:nrow(screener)){
if (screener$child_yesno[i] == 1 & screener$pregnant_yesno[i] == 1) {
if (!is.na(screener$current_age[i]) & screener$current_age[i] <= 135) {
new_row <- screener[i, ]
new_row$child_yesno <- NA
new_row$child_dob <- NA
screener$pregnant_yesno[i] <- NA
screener$due_date[i] <- NA
screener <- rbind(screener, new_row)
}
}
}
screener <- mutate(screener, expected_invite_date = case_when(
child_yesno == 1 & current_age <= 135 ~ child_dob + 107,
pregnant_yesno == 1 ~ due_date + 107
))
screener <- unite(screener, caregiver_name, caregiver_firstname, caregiver_lastname, sep = " ", na.rm = TRUE)
screener$texting_okay <- gsub(1, "Yes", screener$texting_okay)
screener$texting_okay <- gsub(0, "No", screener$texting_okay)
screener$over_18 <- gsub(1, "Yes", screener$over_18)
screener$over_18 <- gsub(0, "No", screener$over_18)
screener$language <- gsub(1, "English", screener$language)
screener$language <- gsub(2, "Spanish", screener$language)
screener$language <- gsub(3, "Other (check redcap)", screener$language)
screener <- filter(screener, bot_check == 3)
View(screener)
col_order <- c("screener_record_id", "caregiver_name", "language", "phone", "texting_okay", "email", "over_18", "zipcode", "child_yesno", "child_dob", "pregnant_yesno", "due_date","twin_yesno", "timestamp","timezone", "location", "rec_source", "rural", "non_white", "low_ses", "priority", "expected_invite_date", "bot_check", "bot_pic_answer")
View(screener)
screener <- screener[, col_order]
screener <- dplyr::arrange(screener, timestamp)
View(screener)
setwd("/Users/amyhume/OrcaData2")
setwd("/Users/amyhume/OrcaData2")
roxygen2::roxygenise()
